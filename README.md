# Digital Design I
Quine-McCluskey Logic Minimization

Ahmed Moamen,
Youssof Alwardany,
Aly


# Building Project:
You must first access the code button, which is situated above the project in the page's upper right corner, in order to build and run a project. You must then select the download choice in order to save the project files to your computer. Once you've downloaded the project files, you can open them in Xcode or Visual Studio by starting a new project and selecting the choice for existing files. In order to execute the project, you can finally compile and build it.

# Main Function:(All group memebrs)
A set numberOfVariables, which is used to maintain track of the various variables present in each function, is one of the data structures that the function first initializes. a vector result, used to store the results of breaking each function down into its sum-of-products terms, a vector convertedSop, used to store the results of turning each term into binary form, and a vector minterms, used to store the decimal version of each binary term.

The validateSOP function is then used by the code to iteratively check each function in the functions array. The code prints the initial function to the console and starts processing it if a function is valid. Using the splitStringByPlus function, the code first divides the function into its sum-of-products elements before storing the outcome in the result vector. Following that, it loops through every term in the outcome vector, recording the distinct variables in the numberOfVariables set. Each term's size in binary form is determined by the number of distinct variables it contains, and then the term is transformed into a binary form using the convert function. Each binary term is then converted to its decimal equivalent and saved in the minterms vector. The Get_prime_Implicants function is then used to locate the function's prime implicants, with the resulting information being stored in the PI array. The epifinder function is then used to identify the crucial prime implicants, with the resulting information being kept in the epis set. Finally, the code clears the numberOfVariables and result data structures before moving on to the following function in the functions vector.

Overall, using different helper functions, this primary function offers a way to validate and process a collection of boolean functions. The code could be applied to research or instructional purposes to examine and work with boolean functions.

#Function Validate the SOP(bool validateSOP(string &sop)) Ahmed Moamen
A function called validateSOP in the provided code receives a reference to a string sop as an argument and returns a boolean value showing whether the string sop is a legitimate sum-of-products (SOP) expression. 
First, the algorithm removes any whitespace from the input string sop using a regular expression. The function then creates a collection of regular expressions for each part of a legitimate SOP expression. These expressions are combined to form a more intricate expression that summarizes the SOP expression as a whole. A variable name represented by a single lowercase character is matched by the varName expression. A variable name with an optional single quotation character denoting a negation is matched by the varNameOptQuotes expression. Expression refers to a group of variable names that are divided up by multiplying. A collection of terms that have been added apart are matched by the groupOfTerms expression. A string of one or more terms separated by addition is how the sopRegex expression finally depicts the complete SOP expression.The input string sop is then compared to the sopRegex regular expression using the regex_match method. The function returns true, showing that the input string is a legitimate SOP expression, if the input string matches the expression. The function gives false in the other case.

Overall, using a set of predefined regular expressions, this function offers a means to determine whether an input string is a legitimate SOP expression. Before carrying out any additional computations or manipulations, the code could be used to verify that an input expression is in a valid format.


# FUNCTION Truth Table Generation and Minterms(vector<int> print(vector<string> function, int size)) youssof Alwardany
After reading in and validating the boolean function given as a SoP, the next step is printing out the function’s truth table, canonical SoP, and PoS. The first step to achieve this task was to create a function, titled ‘splitString’, to split the input string (SoP) into substrings using “+” as the delimiter. In order to do that, built- in functions from C++ such as ‘find()’ and ‘substr()’ were used. The separated substrings are pushed back in a vector and returned at the end by the function. That returned vector is then inputted into the following function (“convert” function) alongside the number of variables which is calculated in the main function using sets. The idea of this function is to convert each string in the vector into a new string consisting of  0’s, 1’s, and -’s. As later on in the program this converted string will be used to compare to the values in the truth table to decide what the output will be. For each string in the input vector, the function creates a new string (the size of the string is the same as the number of variables in the function) and fills it initially with ‘-’. Then the function loops over every character in each string in the input vector; if the character is a latin letter it sets the corresponding index in the new vector to ‘1’ or ‘0’ depending on whether this variable is complemented or not. The function understands the symbol (‘) used when a variable is complemented, and if it detects this symbol it sets the multiplier to 0 (which is initialized initially to 1) to indicate the current variable term is negated in the function otherwise the multiplier stays as 1. Each converted string is pushed back in the returned vector by the function. The next and final function for this part of the code is the ‘print function’, which prints the truth table, canonical SoP, and PoS. The print function starts by creating a 2D vector of type int called ‘table’  that represents the truth table, the rows of the table are equal to 2 to the power of the number of variables, and the column size is equal to the number of variables. Using a nested loop the vector is filled with all possible combinations of 0’s and 1’s for the given number of variables. The function then creates a boolean vector called “F” of size equal to the number of rows, and the vector is initialized with all false values. This vector is used to represent the output of the boolean function for each row in the truth table. Then another vector is created called “tableU”, this time of type string, the function converts the values in the table to strings and puts them tableU. The function then enters a nested loop to fill the values of the output vector. For every row in the truth table it checks for a match in the converted vector that is inputted to this print function. If the row value matches the boolean function or the function value is a don’t care term (represented by ‘-’), a counter integer variable is incremented. After the inner loop is exited, if the counter is equal to the number of variables then the output vector for this row ‘F[i]’ is set to true, otherwise it is set to false. Then loops are used,in the first single loop the variable names are printed in alphabetical order, then ‘F’ is printed to show the column representing the output. Following that is a nested loop prints the truth table itself , where in each row the value of the variables are printed followed by the output value for the boolean function. The loop uses spaces and cout’s to make the table readable and in proper format. 

The values in the printed truth table are used to print the SoP and PoS. This is done by creating two integer vectors, one for SoP (called SoPlines) and the other for PoS (and PoSlines). A loop is used to go through all values of ‘F’, if F[i] is equal to true (1) then the value of i is pushed back the SoP vector, otherwise if F[i] is equal to false (0) then the value of i is pushed back in PoS vector. Then another two vectors, SoPvalues and PoSvalues, are created, each initialized to the size of its respective vector lines. Then loops are used to print SoP and PoS in the correct clear canonical form. The function finally returns the SoPLines vector as it will be needed in the following function in the program.

All in all, this part is implemented by calling the spliString function and putting its return vector in the convert function in addition to the number of variables, then the returned vector is put into the print function to print all 3 of the truth table, canonical SoP, and PoS. This design divides the task of printing into several steps to run smoothly and fit within the rest of the program. 

# Prime Implicants Ali Fakhereldein

Introduction:
This section of the code works by generating prime implicants from a set of minterms that are passed to it. It is a part of the Quine-McCluskey algorithm that is essential to the functionality of the program. To implement this, a custom class called coveredBool which is a boolean value that is used to represent the implicants. Further on, the code then uses a class to group minterms that have the same number of 1s and uses the hammingDistance() function to check if the distance between two minterms only differs by one bit. If so, the program combines them both into one minterm and represents the differing bit by a “-”. Finally, from those combined minterms, the program can generate prime implicants. 

CoveredBool Class:
The coveredBool class has three member variables: value, coverIndexes, and isCombined. The value variable representing the value of the coverIndexes vector represents the indices of minterms that are covered by this specific instance of coveredBool. Further on, the isCombined variable acts as a flagging variable where it shows if the specific instance of coveredBool has been combined with another implicant or not. This class also has 3 different constructors that can be called. The first of which works by initializing a value and isCombined variable to empty string and false. The next, works by initializing the value and coverIndexes with only one index of a minterm. Finally, the last constructor works by creating the value and coverIndexes vector with a vector of minterm indices.

Furthermore, this class has some overloaded functions which are: operator==, operator<,operator

Combine_minterms:
When given two coveredBool objects as input, the combine minterms method merges them into a single coveredBool object if their differences are only one bit. The function iterates through the bits of the two input objects and initializes a new coveredBool object named result. The function increases a counter named diffCount if the bits are different. The function produces an empty coveredBool object if the counter is greater than 1. Otherwise, the function adds a '-' to the result string. The function adds the bit to the result string if the bits are the same. The function then returns the result object and sets the coverIndexes variable of the result object to the coverIndexes of the two input objects if the two input objects only differ by one bit.

Hamming Distance Function:
The hamming distance functions work by taking two strings and iterating through them, essentially, looking to see if each bit at the specified position (i) is equivalent. If they are, then it continues. However, if it is not equivalent then, the difference variable is incremented by 1 for each time that both bits differ at the same position. 

Generate_covered_bools Function:

The generate_covered_bools function takes a vector of minterms as input and generates a vector of coveredBool objects by invoking the coveredBool constructor for each minterm.

Group Primes Function:
The group primes function takes a vector of vectors of coveredBool objects as input and groups the coveredBool objects by the number of 1's in their values. The function then combines adjacent groups of coveredBool objects that differ by only one bit using the combine_minterms function. Finally, the function generates prime implicants from the combined coveredBool objects and returns it to be used by the program. 

Conclusion:
The given C++ program uses the Quine-McCluskey algorithm to generate prime implicants from a given set of minterms. The program defines a custom coveredBool class and uses it to group minterms and combine adjacent groups of minterms that differ by only one bit. The program then generates prime implicants from the combined minterms. The program can be improved by using a more efficient algorithm for finding adjacent groups of minterms that differ by only one bit.

My Contribution & Problems faced:
Personally, I worked on the 3rd requirement of the project description and I faced a lot of issues during this stage. For example, I had to completely restart writing the code a couple of times because there were errors to do with the functionality of the code. Moreover, I also contributed to ⅓ of the report and my teammates and I, all worked collaboratively to help each other. For example, if one of my teammates had a bug with their code, I would go and try to help them out and they would also do the same. 



# FUNCTION EPIFINDER(set <string> epifinder(vector<string> pi, int n, vector<int> minterms)) Ahmed Moamen
 Functionality:
The EPI Finder is a technique for minimizing boolean expressions, and is implemented by passing Prime Implicants(PI), Number of variables(n), and Minterms are the three inputs required by the function.

The function starts by initializing an empty set named epis, which will be used to store the function's essential prime implicants. The empty set epis is then returned if the dimension of the pi vector is equal to 1. As this is the base case of the function.

The PI vector is followed by a 2D vector called checkEPI, which has the same number of rows as the PI and columns as the minterms vector. This 2D vector is used to determine whether each prime implicant covers which minterm. The remaining collection, which has all the minterms, is then initialized. The leftover minimum terms that have not yet been implicated by an essential prime will be tracked by this set. The minterms are then converted to binary values by the function, which then saves them in the vector mintermsB. Additionally, the piS vector holds the binary values that were converted from the PI vector. The input is a pi vector of strings, where each string indicates a term used in a product. It iterates through each component of pi, initializing a temporary string named temp with n dashes for each component. After that, the code iterates over each character in the present element of pi. The character "a" is subtracted from each character in the code to determine its meaning as an integer. The value is used to change the corresponding character in temp to the character '0' or '1' + the multiplier's value. The multiplier is set to 0, signaling that the corresponding variable in the product term should be inverted, if the character is an apostrophe. If not, the number is reset to 1. The temp string is added to the piS vector following the completion of the inner iteration. Finally, each product term from the input vector pi is represented as a string in the piS vector that is produced.

The function then determines whether each prime implicant and each minterm are encompassed by the other. A minterm's associated entry in the checkEPI vector is set to true if a prime implicant covers it. By determining how many minimum terms each prime implicant spans, the function then determines the essential prime implicants. A prime implicant is added to the set episI if it is the only PI that covers this minterm. The function then takes the called minterms out of the collection that is still in existence.

The essential prime implicants are then used to complete the set epis by the function. The function then takes the essential called minterms and essential prime implicants out of the PI vector, leaving only the prime implicants.  The remaining prime implicants and the associated minimum terms that they cover are then used to complete the vector equation. The function then outputs the final minimized equation, the leftover minterms by EPI, and the Essential prime implicants.



Limitations:
Given that it compares all minterms against all PIs using nested loops, the function might not scale well for big inputs. The function's time complexity will rise as minterms and PIs multiply, which could result in speed problems or memory restrictions. A few issues cropped up while the epifinder feature was being developed. One of the major issues was repeatedly iterating over the pi table to look for essential prime implicants (EPIs) without compromising the table's integrity. To keep track of which minimum terms are covered by each prime implicant, meticulous indexing and the use of boolean matrices were necessary. Finding the smallest number of PIs necessary to complete the reduced equation while also keeping track of the minterms that are still unmet was another difficult task. In order to maintain track of which PIs have already been used and which minterms are still available, careful manipulation of sets and vectors was necessary.
